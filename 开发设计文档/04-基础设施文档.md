# IM 系统基础设施文档

## 文档概述

本文档详细描述 IM 系统的基础设施组件设计与实现，包括：
- NATS消息总线通信架构：主题设计、通信模式、可靠性保障
- 协议与数据契约：Protobuf契约、WebSocket传输、HTTP接口
- 聊天会话模型：会话类型、数据模型、序号与顺序保证
- 共享库模块：proto、nats-common、codec、common等通用组件

---

## 3. NATS消息总线通信架构

### 3.1 通信模式设计

#### 核心服务内部通信
- **直接方法调用**: 网关、消息、在线状态模块间直接方法调用
- **共享内存**: 连接信息、用户状态、会话数据在内存中共享
- **零网络延迟**: 内部通信无网络开销，响应更快

#### 业务服务内部通信
- **直接方法调用**: 权限、媒体、定时任务模块间直接方法调用
- **共享缓存**: 权限缓存、媒体配置、任务状态在内存中共享
- **零网络延迟**: 内部通信无网络开销，响应更快

#### 服务间通信
- **发布/订阅模式**: 消息广播、事件通知、状态变更
- **请求/响应模式**: 权限校验、配置查询等需要即时响应的场景
- **队列组模式**: 负载分担，多个相同服务实例组成队列组

### 3.2 NATS主题设计规范

#### 主题命名规则
```
im.{service}.{action}.{target}
```

#### 核心主题列表
```
# 消息相关
im.message.send              # 发送消息
im.message.deliver           # 消息投递
im.message.ack               # 消息确认
im.message.history           # 历史查询

# 状态相关  
im.presence.online           # 用户上线
im.presence.offline          # 用户下线
im.presence.route            # 路由查询
im.presence.status           # 状态更新

# 权限相关
im.auth.check                # 权限校验
im.auth.member               # 成员关系
im.auth.group                # 群组权限

# 媒体相关
im.media.upload              # 媒体上传
im.media.process             # 媒体处理
im.media.scan                # 内容扫描

# 管理相关
im.admin.config              # 配置更新
im.admin.monitor             # 监控数据
im.admin.audit               # 审计日志
```

### 3.3 服务间通信示例

#### 核心服务内部通信
```java
// 网关模块调用消息模块
@Autowired
private MessageService messageService;

// 消息模块调用在线状态模块
@Autowired
private PresenceService presenceService;

// 在线状态模块调用网关模块
@Autowired
private GatewayService gatewayService;

// 内部方法调用，零延迟
public void handleMessage(MessageRequest request) {
    // 直接调用，无网络开销
    AuthResult auth = authService.checkPermission(request);
    if (auth.isAllowed()) {
        messageService.processMessage(request);
    }
}
```

#### 业务服务内部通信
```java
// 权限模块调用媒体模块
@Autowired
private MediaService mediaService;

// 媒体模块调用定时任务模块
@Autowired
private SchedulerService schedulerService;

// 定时任务模块调用权限模块
@Autowired
private AuthService authService;

// 内部方法调用，零延迟
public void processMediaUpload(MediaUploadRequest request) {
    // 直接调用，无网络开销
    AuthResult auth = authService.checkMediaPermission(request);
    if (auth.isAllowed()) {
        mediaService.processUpload(request);
        schedulerService.scheduleCleanup(request.getMediaId());
    }
}
```

#### 服务间通信
```java
// 核心服务与业务服务通信
nats.publish("im.auth.check", authData);

// 业务服务与管理服务通信
nats.subscribe("im.admin.config", (msg) -> {
    ConfigData data = ConfigData.parseFrom(msg.getData());
    updateConfig(data);
});
```

### 3.4 共享通信模块设计

#### nats-common模块结构
```
shared-libs/
└── nats-common/
    ├── core/
    │   ├── NatsClient.java         # 基础客户端封装
    │   ├── NatsConfig.java         # 配置类
    │   └── NatsHealthCheck.java    # 健康检查
    ├── messaging/
    │   ├── MessagePublisher.java   # 消息发布接口
    │   ├── MessageSubscriber.java  # 消息订阅接口
    │   └── MessageHandler.java     # 消息处理接口
    ├── codecs/
    │   ├── ProtobufCodec.java      # Protobuf编解码
    │   └── JsonCodec.java          # JSON编解码
    ├── patterns/
    │   ├── RequestResponse.java    # 请求响应模式
    │   ├── PubSub.java             # 发布订阅模式
    │   └── QueueGroup.java         # 队列组模式
    └── monitoring/
        ├── NatsMetrics.java        # 监控指标
        └── NatsTracing.java        # 链路追踪
```

#### 核心功能
- **连接管理**: 连接建立、重连、健康检查
- **消息模式**: 发布/订阅、请求/响应、队列组
- **编解码**: Protobuf和JSON编解码
- **监控**: 指标收集、链路追踪
- **高级特性**: 自动重连、熔断器、限流、批量处理

#### 使用示例
```java
// 在核心服务中使用
@Service
public class MessageService {
    private final NatsClient natsClient;
    
    @Autowired
    public MessageService(NatsClient natsClient) {
        this.natsClient = natsClient;
    }
    
    public void sendAuthCheck(AuthCheckRequest request) {
        // 异步请求权限校验
        natsClient.request("im.auth.check", request, AuthCheckResponse.class, Duration.ofSeconds(5))
            .thenAccept(response -> {
                // 处理响应
                if (response.isAllowed()) {
                    // 继续处理消息
                } else {
                    // 拒绝消息
                }
            })
            .exceptionally(ex -> {
                // 处理异常
                log.error("权限校验失败", ex);
                return null;
            });
    }
}
```

### 3.5 NATS可靠性与一致性保障

#### JetStream持久化策略
- **需启用JetStream的关键主题**:
  - `im.auth.*`: 权限相关事件，确保权限变更不丢失
  - `im.admin.config`: 配置更新，确保配置变更可靠送达
  - `im.message.ack`: 消息确认，支持重放与恢复
  - `im.audit.*`: 审计日志，满足合规要求

- **Stream配置**:
  ```
  Stream: im-critical
  Subjects: [im.auth.*, im.admin.config, im.audit.*]
  Retention: Limits
  Storage: File
  Replicas: 3
  MaxAge: 7d
  ```

#### NATS主题配置统一清单

##### 权限与配置主题
| 主题名称 | 持久化 | 重放支持 | 最大重试 | 队列组 | 副本数 | 说明 |
|---------|--------|----------|----------|--------|--------|------|
| im.auth.check | 否 | 否 | 0 | 是 | - | 权限校验，不持久化 |
| im.auth.invalidate | JetStream | 是 | 5 | 是 | 3 | 权限失效通知，必须可靠 |
| im.auth.update | JetStream | 是 | 3 | 是 | 3 | 权限更新，必须可靠 |
| im.admin.config | JetStream | 是 | 5 | 是 | 3 | 配置变更，必须可靠 |
| im.admin.monitor | 否 | 否 | 0 | 是 | - | 监控数据，可丢失 |

##### 消息处理主题
| 主题名称 | 持久化 | 重放支持 | 最大重试 | 队列组 | 副本数 | 说明 |
|---------|--------|----------|----------|--------|--------|------|
| im.message.send | 否 | 否 | 0 | 是 | - | 消息发送，不持久化 |
| im.message.ack | JetStream | 是 | 3 | 是 | 3 | 消息确认，必须可靠 |
| im.message.deliver | 否 | 否 | 0 | 是 | - | 消息投递，不持久化 |
| im.message.history | 否 | 否 | 0 | 是 | - | 历史查询，不持久化 |

##### 状态与通知主题
| 主题名称 | 持久化 | 重放支持 | 最大重试 | 队列组 | 副本数 | 说明 |
|---------|--------|----------|----------|--------|--------|------|
| im.presence.update | 否 | 否 | 0 | 是 | - | 在线状态，可丢失 |
| im.presence.route | 否 | 否 | 0 | 是 | - | 路由信息，可丢失 |
| im.notification.push | JetStream | 是 | 5 | 是 | 3 | 推送通知，必须可靠 |
| im.audit.log | JetStream | 是 | 3 | 是 | 3 | 审计日志，必须可靠 |

#### 消费者配置规范
1. **权限变更消费者**：
   ```
   Consumer: auth-changes
   DeliverPolicy: All
   AckPolicy: Explicit
   MaxDeliver: 5
   AckWait: 30s
   FilterSubject: im.auth.*
   ```

2. **配置更新消费者**：
   ```
   Consumer: config-updates
   DeliverPolicy: All
   AckPolicy: Explicit
   MaxDeliver: 5
   AckWait: 60s
   FilterSubject: im.admin.config
   ```

3. **消息确认消费者**：
   ```
   Consumer: message-ack
   DeliverPolicy: All
   AckPolicy: Explicit
   MaxDeliver: 3
   AckWait: 15s
   FilterSubject: im.message.ack
   ```

#### 重试与降级策略
1. **重试策略**：
   - 权限/配置：指数退避，最大重试5次
   - 消息确认：线性退避，最大重试3次
   - 审计日志：固定间隔，最大重试3次

2. **降级策略**：
   - 权限服务不可用：使用本地缓存，记录告警
   - 配置服务不可用：使用默认配置，记录告警
   - 消息确认失败：异步重试，不影响正常发送

3. **监控指标**：
   - 重试率：按主题分类统计
   - 处理延迟：P50、P95、P99
   - 失败率：按错误类型分类统计

#### 消费语义与重复处理
- **消费模式**:
  - 权限/配置: 至少一次(At-Least-Once)
  - 消息投递: 最多一次(At-Most-Once)

- **消费者配置**:
  ```
  // 权限变更消费者
  Consumer: auth-changes
  DeliverPolicy: All
  AckPolicy: Explicit
  MaxDeliver: 5
  AckWait: 30s
  ```

- **去重策略**:
  - 消息ID: `{publisher}-{timestamp}-{sequence}`
  - 去重窗口: 使用Redis Sorted Set存储5分钟
  - 处理逻辑: 收到重复消息ID时忽略处理

#### 消费者并发与监控
- **并发配置**:
  - 队列组大小: 分片数 × 1.5
  - 每节点消费者线程: CPU核心数 × 0.7

- **监控指标**:
  - `nats_jetstream_messages_count`: 消息总量
  - `nats_consumer_ack_pending`: 待确认消息数
  - `nats_consumer_redelivered`: 重传消息数
  - `nats_consumer_processing_time`: 处理时间

- **告警阈值**:
  - 待确认消息积压: >1000条
  - 重传率: >1%
  - 处理延迟: >500ms

---

## 4. 协议与数据契约

### 3.1 Protobuf契约规范

#### 版本管理
- **位置**: `shared-libs/proto`
- **版本策略**: 语义化版本 vMAJOR.MINOR.PATCH
- **兼容性**: 新增字段仅append，不删除/重命名
- **枚举处理**: 预留保留位，未知值按兼容策略降级处理

#### 核心消息结构
```protobuf
// Envelope - 统一消息包装
message Envelope {
  Header header = 1;
  oneof payload {
    SendMessageReq send = 10;
    Ack ack = 11;
    Heartbeat hb = 12;
    Receipt read = 13;
    Typing typing = 14;
  }
}

// Header - 消息头
message Header {
  string traceId = 1;
  string clientMsgId = 2;
  int64 timestamp = 3;
  string codecVersion = 4;
  string deviceId = 5;
  int64 userId = 6;
}

// SendMessageReq - 发送消息请求
message SendMessageReq {
  string conversationId = 1;
  string clientMsgId = 2;
  MessageType type = 3;
  oneof content {
    string textContent = 4;
    MediaRef mediaRef = 5;
  }
  map<string, string> meta = 6;
}

// MediaRef - 媒体引用
message MediaRef {
  string mediaId = 1;
  string url = 2;
  int64 size = 3;
  string md5 = 4;
  string mime = 5;
  int32 duration = 6;
  int32 width = 7;
  int32 height = 8;
  string thumbnailUrl = 9;
}
```

### 3.2 WebSocket传输规范

#### 帧格式
- **承载方式**: 二进制帧承载Protobuf Envelope
- **分帧策略**: 采用长度前缀（varint）分帧
- **心跳机制**: 客户端定期Ping，服务端心跳窗口内未收到则关闭连接

#### ACK机制
- **上行确认**: 成功回执 `Ack{clientMsgId, serverMsgId, seq, status}`
- **状态流转**: SENT → STORED → DELIVERED → READ

### 3.3 HTTP/REST接口

#### 媒体上传接口
- **小文件直传**: `POST /media/upload`
- **大文件预签名**: `POST /media/sts`

#### 历史拉取接口
- **分页查询**: `GET /history?conversationId&fromSeq&limit&direction`

#### 管理接口
- **权限查询**: `GET /conv/{id}/members`
- **角色查询**: `GET /conv/{id}/role/me`
- **操作接口**: `POST /conv/{id}/mute|/blacklist`

---

## 4. 聊天会话模型

### 4.1 会话类型与策略

#### 会话分类
- **单聊（P2P）**: 参与者固定为两方，逻辑上可去重（A-B与B-A）
- **群聊（Group）**: 多成员，支持角色（owner/admin/member）、禁言、黑名单

#### ID生成策略
- **conversationId**: 全局唯一，雪花算法或随机+类型前缀
- **单聊映射**: `convId = hash(sorted(userA, userB))`，保留独立元数据表便于扩展

### 4.2 数据模型设计

#### 核心表结构
```sql
-- 会话表
CREATE TABLE conversation (
  id BIGINT PRIMARY KEY,
  conversation_id VARCHAR(64) UNIQUE NOT NULL,
  type TINYINT NOT NULL COMMENT '1:单聊 2:群聊',
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  last_msg_seq BIGINT DEFAULT 0,
  last_msg_at TIMESTAMP,
  ext JSON COMMENT '扩展字段'
);

-- 会话成员表
CREATE TABLE conversation_member (
  id BIGINT PRIMARY KEY,
  conversation_id VARCHAR(64) NOT NULL,
  user_id BIGINT NOT NULL,
  role TINYINT DEFAULT 0 COMMENT '0:成员 1:管理员 2:群主',
  mute_until TIMESTAMP NULL,
  join_at TIMESTAMP NOT NULL,
  last_read_seq BIGINT DEFAULT 0,
  last_ack_at TIMESTAMP,
  ext JSON,
  UNIQUE KEY uk_conv_user (conversation_id, user_id)
);

-- 消息表
CREATE TABLE message (
  id BIGINT PRIMARY KEY,
  conversation_id VARCHAR(64) NOT NULL,
  seq BIGINT NOT NULL,
  from_user_id BIGINT NOT NULL,
  type TINYINT NOT NULL,
  content TEXT,
  blob_ref VARCHAR(255),
  meta JSON,
  status TINYINT DEFAULT 0,
  created_at TIMESTAMP NOT NULL,
  shard_key VARCHAR(32) NOT NULL,
  UNIQUE KEY uk_conv_seq (conversation_id, seq),
  KEY idx_conv_time (conversation_id, created_at)
);
```

#### 索引策略
- **唯一索引**: `conversation_member(conversation_id, user_id)`
- **排序索引**: `message(conversation_id, seq)`、`message(conversation_id, created_at)`

### 4.3 序号与顺序保证

#### 消息序号分配与顺序保证

##### 序号分配策略
1. **全局序号生成**：
   - 使用Redis INCRBY生成全局递增序号
   - 按conversationId分片，避免热点
   - 序号格式：`{conversationId}:{timestamp}:{sequence}`
2. **本地序号缓存**：
   - 每个节点维护本地序号池
   - 批量预分配序号，减少Redis调用
   - 序号池大小：1000个，低于200时自动补充

##### 消息顺序保证机制
1. **唯一编号分配**：
   - 每条消息分配唯一编号：`{conversationId}-{seq}-{timestamp}`
   - 编号在消息落库前分配，确保顺序性
   - 编号作为消息的唯一标识，用于去重和排序
2. **顺序检查策略**：
   - 落库时检查序号连续性
   - 发现序号跳跃时记录告警
   - 序号重复时直接丢弃，记录日志

##### 消息去重与重复处理
1. **去重策略**：
   - 使用clientMsgId作为去重键
   - Redis TTL：7天，避免内存泄漏
   - 分片存储：按clientMsgId哈希分片
2. **重复消息处理**：
   - 收到重复clientMsgId时，返回已存在消息的状态
   - 不重复落库，避免数据冗余
   - 记录重复次数，用于监控分析

#### 消息处理时序图
```
┌─────────┐          ┌─────────┐          ┌─────────────┐          ┌─────────────┐
│ 客户端   │          │ 网关模块  │          │ 消息模块     │          │ 存储层       │
└────┬────┘          └────┬────┘          └──────┬──────┘          └──────┬──────┘
     │                    │                      │                        │
     │   发送消息请求       │                      │                        │
     │───────────────────>│                      │                        │
     │                    │                      │                        │
     │                    │   快速校验通过        │                        │
     │                    │─────────────────────>│                        │
     │                    │                      │                        │
     │                    │                      │   分配序号              │
     │                    │                      │───────────────────────>│
     │                    │                      │                        │
     │                    │                      │   序号分配成功          │
     │                    │                      │<───────────────────────│
     │                    │                      │                        │
     │                    │                      │   检查重复消息          │
     │                    │                      │───────────────────────>│
     │                    │                      │                        │
     │                    │                      │   无重复，开始落库      │
     │                    │                      │<───────────────────────│
     │                    │                      │                        │
     │                    │                      │   消息落库              │
     │                    │                      │───────────────────────>│
     │                    │                      │                        │
     │                    │                      │   落库成功              │
     │                    │                      │<───────────────────────│
     │                    │                      │                        │
     │                    │                      │   更新缓存              │
     │                    │                      │───────────────────────>│
     │                    │                      │                        │
     │                    │                      │   缓存更新成功          │
     │                    │                      │<───────────────────────│
     │                    │                      │                        │
     │  ACK(STORED)       │                      │                        │
     │<───────────────────│<─────────────────────│                        │
     │                    │                      │                        │
     │                    │                      │   开始消息扇出          │
     │                    │                      │                        │
```

#### 异常场景处理
1. **序号分配失败**：
   - 记录错误日志，返回FAILED状态
   - 客户端显示"发送失败"，提供重试选项
2. **重复消息检测**：
   - 返回已存在消息的状态
   - 客户端更新为对应状态
3. **序号跳跃处理**：
   - 记录告警，不影响正常消息处理
   - 定期检查序号连续性，发现问题及时修复

### 4.4 未读与游标
- **未读计数**: `lastReadSeq` per user per conversation
- **大群优化**: 仅计总未读或分层计数，精确未读按需计算

---

## 2.2 共享库模块

### shared-libs（共享库）
- **proto**: Protobuf契约与生成脚本
- **nats-common**: NATS通信封装、消息模式实现、监控与链路追踪
- **codec**: 统一Envelope、编解码器（Proto/JSON）
- **common**: 
  - **utils**: 通用工具类（时间、字符串、加密、ID生成等）
  - **error**: 错误码、重试策略、异常处理
  - **monitor**: 埋点规范、指标收集、追踪上下文
  - **config**: 配置加载与热更新
  - **cache**: 缓存策略与实现
  - **security**: 安全相关工具
- **websocket-push-api**: WebSocket推送接口与模型
- **database-common**: 数据库访问共享组件

#### proto模块详细结构
```
proto/
├── src/
│   ├── main/
│   │   ├── proto/                   # Protobuf定义文件
│   │   │   ├── common/              # 公共定义
│   │   │   │   ├── envelope.proto   # 消息包装
│   │   │   │   └── constants.proto  # 常量定义
│   │   │   ├── message/             # 消息相关
│   │   │   │   ├── message.proto    # 消息定义
│   │   │   │   └── history.proto    # 历史消息
│   │   │   ├── presence/            # 在线状态
│   │   │   │   └── presence.proto   # 状态定义
│   │   │   ├── auth/                # 权限相关
│   │   │   │   └── auth.proto       # 权限定义
│   │   │   ├── media/               # 媒体相关
│   │   │   │   └── media.proto      # 媒体定义
│   │   │   ├── rtc/                 # 音视频相关
│   │   │   │   └── signaling.proto  # 信令定义
│   │   │   └── admin/               # 管理相关
│   │   │       └── admin.proto      # 管理定义
│   │   └── java/                    # 生成的Java代码
│   └── test/                        # 测试代码
├── build.gradle                     # 构建脚本
└── README.md                        # 使用说明
```

#### nats-common模块详细结构
```
nats-common/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── core/
│   │   │   │   ├── NatsClient.java         # 基础客户端封装
│   │   │   │   ├── NatsConfig.java         # 配置类
│   │   │   │   └── NatsHealthCheck.java    # 健康检查
│   │   │   ├── messaging/
│   │   │   │   ├── MessagePublisher.java   # 消息发布接口
│   │   │   │   ├── MessageSubscriber.java  # 消息订阅接口
│   │   │   │   └── MessageHandler.java     # 消息处理接口
│   │   │   ├── codecs/
│   │   │   │   ├── ProtobufCodec.java      # Protobuf编解码
│   │   │   │   └── JsonCodec.java          # JSON编解码
│   │   │   ├── patterns/
│   │   │   │   ├── RequestResponse.java    # 请求响应模式
│   │   │   │   ├── PubSub.java             # 发布订阅模式
│   │   │   │   └── QueueGroup.java         # 队列组模式
│   │   │   └── monitoring/
│   │   │       ├── NatsMetrics.java        # 监控指标
│   │   │       └── NatsTracing.java        # 链路追踪
│   │   └── resources/
│   │       └── nats-default.yml            # 默认配置
│   └── test/                                # 测试代码
├── build.gradle                             # 构建脚本
└── README.md                                # 使用说明
```

#### codec模块详细结构
```
codec/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── envelope/
│   │   │   │   ├── EnvelopeEncoder.java    # 消息包装编码
│   │   │   │   ├── EnvelopeDecoder.java    # 消息包装解码
│   │   │   │   └── EnvelopeFactory.java    # 消息包装工厂
│   │   │   ├── protobuf/
│   │   │   │   ├── ProtobufCodec.java      # Protobuf编解码
│   │   │   │   └── ProtobufUtils.java      # Protobuf工具类
│   │   │   ├── json/
│   │   │   │   ├── JsonCodec.java          # JSON编解码
│   │   │   │   └── JsonUtils.java          # JSON工具类
│   │   │   └── compression/
│   │   │       ├── CompressionCodec.java   # 压缩编解码
│   │   │       └── CompressionUtils.java   # 压缩工具类
│   │   └── resources/
│   │       └── codec.properties            # 编解码配置
│   └── test/                                # 测试代码
├── build.gradle                             # 构建脚本
└── README.md                                # 使用说明
```

#### common模块详细结构
```
common/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── utils/
│   │   │   │   ├── time/
│   │   │   │   │   ├── TimeUtils.java      # 时间工具类
│   │   │   │   │   └── DateFormatter.java  # 日期格式化
│   │   │   │   ├── string/
│   │   │   │   │   ├── StringUtils.java    # 字符串工具类
│   │   │   │   │   └── TextFormatter.java  # 文本格式化
│   │   │   │   ├── crypto/
│   │   │   │   │   ├── CryptoUtils.java    # 加密工具类
│   │   │   │   │   └── HashUtils.java      # 哈希工具类
│   │   │   │   ├── id/
│   │   │   │   │   ├── IdGenerator.java    # ID生成器
│   │   │   │   │   └── SnowflakeId.java    # 雪花算法ID
│   │   │   │   └── validation/
│   │   │   │       ├── Validator.java      # 验证器
│   │   │   │       └── ValidationUtils.java # 验证工具类
│   │   │   ├── error/
│   │   │   │   ├── ErrorCode.java          # 错误码定义
│   │   │   │   ├── BusinessException.java  # 业务异常
│   │   │   │   ├── SystemException.java    # 系统异常
│   │   │   │   └── retry/
│   │   │   │       ├── RetryStrategy.java  # 重试策略
│   │   │   │       └── RetryExecutor.java  # 重试执行器
│   │   │   ├── monitor/
│   │   │   │   ├── metrics/
│   │   │   │   │   ├── MetricsCollector.java # 指标收集器
│   │   │   │   │   └── MetricsExporter.java # 指标导出器
│   │   │   │   ├── trace/
│   │   │   │   │   ├── TraceContext.java   # 追踪上下文
│   │   │   │   │   └── SpanManager.java    # 跨度管理器
│   │   │   │   └── logger/
│   │   │   │       ├── LoggerFactory.java  # 日志工厂
│   │   │   │       └── LogFormatter.java   # 日志格式化
│   │   │   ├── config/
│   │   │   │   ├── ConfigLoader.java       # 配置加载器
│   │   │   │   ├── ConfigWatcher.java      # 配置监听器
│   │   │   │   └── ConfigValidator.java    # 配置验证器
│   │   │   ├── cache/
│   │   │   │   ├── CacheManager.java       # 缓存管理器
│   │   │   │   ├── LocalCache.java         # 本地缓存
│   │   │   │   ├── RedisCache.java         # Redis缓存
│   │   │   │   └── CacheEvictionPolicy.java # 缓存淘汰策略
│   │   │   └── security/
│   │   │       ├── TokenManager.java       # 令牌管理器
│   │   │       ├── PasswordEncoder.java    # 密码编码器
│   │   │       └── SecurityUtils.java      # 安全工具类
│   │   └── resources/
│   │       └── common.properties           # 通用配置
│   └── test/                                # 测试代码
├── build.gradle                             # 构建脚本
└── README.md                                # 使用说明
```

#### websocket-push-api模块详细结构
```
websocket-push-api/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── model/
│   │   │   │   ├── PushMessage.java        # 推送消息模型
│   │   │   │   ├── PushTarget.java         # 推送目标
│   │   │   │   └── PushResult.java         # 推送结果
│   │   │   ├── service/
│   │   │   │   ├── PushService.java        # 推送服务接口
│   │   │   │   └── PushCallback.java       # 推送回调接口
│   │   │   ├── constants/
│   │   │   │   ├── PushType.java           # 推送类型
│   │   │   │   └── PushPriority.java       # 推送优先级
│   │   │   └── exception/
│   │   │       └── PushException.java      # 推送异常
│   │   └── resources/
│   │       └── push-api.properties         # 推送API配置
│   └── test/                                # 测试代码
├── build.gradle                             # 构建脚本
└── README.md                                # 使用说明
```

#### database-common模块详细结构
```
database-common/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── mongo/
│   │   │   │   ├── MongoConfig.java        # MongoDB配置
│   │   │   │   ├── MongoClientFactory.java # 客户端工厂
│   │   │   │   └── MongoHealthCheck.java   # 健康检查
│   │   │   ├── mysql/
│   │   │   │   ├── MySQLConfig.java        # MySQL配置
│   │   │   │   ├── DataSourceFactory.java  # 数据源工厂
│   │   │   │   └── MySQLHealthCheck.java   # 健康检查
│   │   │   ├── redis/
│   │   │   │   ├── RedisConfig.java        # Redis配置
│   │   │   │   ├── RedisClientFactory.java # 客户端工厂
│   │   │   │   └── RedisHealthCheck.java   # 健康检查
│   │   │   └── common/
│   │   │       ├── ConnectionPoolConfig.java # 连接池配置
│   │   │       ├── TransactionManager.java # 事务管理器
│   │   │       └── DatabaseMetrics.java    # 数据库指标
│   │   └── resources/
│   │       └── database-default.yml        # 默认配置
│   └── test/                                # 测试代码
├── build.gradle                             # 构建脚本
└── README.md                                # 使用说明
```

### 2.3 项目目录结构
```
im-distributed/
├── shared-libs/
│   ├── proto/          # Protobuf定义
│   ├── nats-common/    # NATS通信封装
│   ├── codec/          # 编解码器
│   └── common/         # 公共组件
├── im-core-service/     # 核心单体服务（网关+消息+在线状态）
├── im-business-service/ # 业务单体服务（权限+媒体+定时任务）
└── im-admin-service/    # 管理与运维服务
```

### 2.4 服务间通信与依赖关系

#### 服务间依赖
- **im-core-service**:
  - 依赖shared-libs中的所有模块
  - 通过NATS请求im-business-service进行权限校验和媒体处理
  - 接收im-admin-service的配置更新
- **im-business-service**:
  - 依赖shared-libs中的所有模块
  - 通过NATS请求im-core-service获取消息数据和在线状态
  - 接收im-admin-service的配置更新
- **im-admin-service**:
  - 依赖shared-libs中的所有模块
  - 通过NATS向im-core-service和im-business-service发布配置
  - 通过NATS接收各服务的监控数据

#### 数据库访问职责
- **im-core-service**:
  - 直接访问MongoDB进行消息存储和查询
  - 直接访问Redis进行在线状态和路由管理
  - 不直接访问MySQL
- **im-business-service**:
  - 直接访问MySQL进行业务数据管理
  - 直接访问Redis进行权限缓存和媒体处理状态管理
  - 不直接访问MongoDB
- **im-admin-service**:
  - 直接访问MySQL进行配置和审计数据管理
  - 直接访问Redis进行配置缓存
  - 可以通过NATS请求访问MongoDB中的消息数据（用于审计）

---

## 24. 高可用与容灾设计

### 24.1 NATS集群拓扑与高可用

#### 集群拓扑设计
```
                  ┌─────────────────────────────────────────────┐
                  │               负载均衡层                     │
                  └───────────────────┬─────────────────────────┘
                                      │
┌─────────────────────────┬───────────┴──────────┬─────────────────────────┐
│                         │                      │                         │
▼                         ▼                      ▼                         ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  NATS节点1      │ │  NATS节点2      │ │  NATS节点3      │ │  NATS节点4      │
│  (AZ-1)         │ │  (AZ-1)         │ │  (AZ-2)         │ │  (AZ-2)         │
└─────────────────┘ └─────────────────┘ └─────────────────┘ └─────────────────┘
       │                   │                   │                   │
       └───────────────────┴───────────────────┴───────────────────┘
                                      │
                                      ▼
┌─────────────────────────┬───────────┴──────────┬─────────────────────────┐
│                         │                      │                         │
▼                         ▼                      ▼                         ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  JetStream      │ │  JetStream      │ │  JetStream      │ │  JetStream      │
│  存储节点1       │ │  存储节点2       │ │  存储节点3       │ │  存储节点4       │
│  (AZ-1)         │ │  (AZ-1)         │ │  (AZ-2)         │ │  (AZ-2)         │
└─────────────────┘ └─────────────────┘ └─────────────────┘ └─────────────────┘
```

#### 跨可用区部署策略
- **节点分布**：至少跨两个可用区部署，每个可用区至少2个节点
- **仲裁策略**：采用N/2+1仲裁机制，确保单可用区故障时集群仍可用
- **JetStream存储**：数据复制因子为3，确保数据可靠性
- **路由节点**：每个可用区部署专用路由节点，优化跨区流量

#### 客户端连接策略
- **连接池设计**：
  - 初始连接数：CPU核心数 × 0.75
  - 最大连接数：CPU核心数 × 1.5
  - 连接存活检测：30秒心跳
  - 空闲超时：5分钟

- **优先就近连接**：
  - 客户端优先连接同可用区NATS节点
  - 连接信息包含区域标识，用于路由决策
  - 故障时自动切换到其他可用区节点

- **断线重连策略**：
  - 初始重试间隔：100ms
  - 最大重试间隔：30s
  - 指数退避因子：1.5
  - 抖动因子：0.2
  - 最大重试次数：无限（持续尝试）

#### 发布确认与流控
- **发布确认(PubAck)**：
  - 关键消息启用发布确认
  - 确认超时：2秒
  - 未确认处理：重试或降级

- **背压处理(Backpressure)**：
  - 发布侧缓冲区：1MB或1000条消息
  - 缓冲区满策略：阻塞或拒绝
  - 背压指标监控：`nats_client_pending_bytes`、`nats_client_pending_msgs`

#### 请求/响应模式优化
- **超时控制**：
  - 默认请求超时：2秒
  - 权限校验请求：300ms
  - 配置查询请求：500ms
  - 历史查询请求：1秒

- **重试策略**：
  - 快速失败请求：不重试（如权限校验）
  - 幂等请求：最多重试2次，间隔100ms
  - 非幂等请求：不自动重试，返回错误由业务层处理

- **幂等处理**：
  - 请求ID格式：`{serviceId}-{timestamp}-{sequence}`
  - 幂等窗口：60秒
  - 幂等存储：Redis Sorted Set，按时间戳淘汰

### 24.2 Redis热键与容量风险管理

#### 热键识别与防御
- **热键定义**：
  - 访问频率：>1000次/秒
  - 响应时间：P99 >1ms
  - 内存占用：单键>1MB

- **热键识别方法**：
  - 定期采样：使用`redis-cli --hotkeys`
  - 实时监控：使用`MONITOR`命令采样分析
  - 自动化工具：Redis热键分析脚本
  ```bash
  redis-cli -h $HOST -p $PORT --hotkeys -i 0.1 -d 5
  ```

- **热键防御策略**：
  ```
  ┌─────────────────┐
  │  应用层         │
  │  本地缓存       │──┐
  └─────────────────┘  │ 缓存未命中
                       ▼
  ┌─────────────────┐  │ 首次查询
  │  Redis主节点    │◄─┘
  └─────────────────┘
          │
          │ 复制
          ▼
  ┌─────────────────┐
  │  Redis从节点    │
  │  只读查询       │
  └─────────────────┘
  ```

#### 大群数据结构优化
- **在线成员存储优化**：
  ```
  # 传统方式(可能成为热键)
  subscribers:conv:{conversationId} → Set(userId1, userId2, ...)
  
  # 优化方式(分桶)
  subscribers:conv:{conversationId}:bucket:{bucketId} → Set(userId1, userId2, ...)
  ```

- **分桶策略**：
  - 桶数量：成员数/1000，至少10个桶
  - 分桶算法：`bucketId = hash(userId) % bucketCount`
  - 查询策略：并行查询多个桶，合并结果

- **数据结构选择**：
  - 小群(<100人)：使用SET
  - 中群(100-1000人)：使用ZSET，按活跃度排序
  - 大群(>1000人)：分桶+BITMAP

#### Redis Cluster槽位优化
- **键名设计**：
  - 使用`{}`定义哈希标签：`presence:{userId}`
  - 确保相关键在同一槽位：`route:{deviceId}`和`presence:{userId}`使用相同标签

- **槽位分布监控**：
  - 定期检查槽位分布均衡性
  - 热点槽位识别：`redis-cli --bigkeys`结合`CLUSTER NODES`
  - 自动均衡脚本示例：
  ```bash
  for slot in $(redis-cli cluster slots | grep "hot-slot"); do
    redis-cli cluster setslot $slot migrating $TARGET_NODE_ID
  done
  ```

#### 容量规划与扩容策略
- **容量指标**：
  - 内存使用率阈值：70%
  - 连接数阈值：每节点10000
  - CPU使用率阈值：65%

- **扩容触发条件**：
  - 内存使用率>60%持续7天
  - 连接数>8000持续3天
  - CPU使用率>50%持续5天

- **扩容步骤**：
  1. 添加新节点到集群
  2. 重新分片，迁移槽位
  3. 监控迁移进度和性能影响
  4. 更新客户端配置

- **热点迁移演练**：
  1. 识别热点键和槽位
  2. 创建影子键，双写测试
  3. 切换读流量到影子键
  4. 完全迁移并清理原键

---

## 文档版本信息

- **版本**: 5.0.0
- **最后更新**: 2024年
- **维护团队**: IM架构组
- **架构模式**: 分布式单体架构（核心服务+业务服务合并优化）
- **通信方式**: 服务内部直接调用 + NATS消息总线 + 共享库
- **审核状态**: 已审核 